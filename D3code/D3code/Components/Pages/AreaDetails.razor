@page "/area-details/{AreaId:int}"
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer
@using System.Net.Http.Json
@using System.Text.Json
<div class="container mx-auto min-h-screen bg-white p-6">
    <h1 class="mb-6 text-4xl font-extrabold tracking-tight text-blue-900">Leon Hospital Data</h1>
    @if (isLoading)
    {
        <div class="flex items-center justify-center py-12">
            <div class="h-12 w-12 animate-spin rounded-full border-4 border-blue-500 border-t-transparent"></div>
            <span class="ml-3 text-lg font-medium text-gray-700">Loading...</span>
        </div>
    }
    else if (areaInfo == null)
    {
        <div class="flex items-center rounded-lg border border-red-200 bg-red-50 p-4 text-red-700">
            <svg class="mr-2 h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z" clip-rule="evenodd" />
            </svg>
            <p>No details found for this area.</p>
        </div>
    }
    else
    {
        <div class="mb-8 rounded-xl border border-gray-100 bg-white p-6 shadow-lg">
            <h2 class="mb-4 text-2xl font-semibold text-blue-900">General Information</h2>
            <div class="grid grid-cols-1 gap-4 text-gray-700 sm:grid-cols-2">
                <p><strong class="font-medium">Latitude:</strong> @areaInfo.Latitude</p>
                <p><strong class="font-medium">Longitude:</strong> @areaInfo.Longitude</p>
                <p><strong class="font-medium">Grid Type:</strong> @areaInfo.GridType</p>
                <p><strong class="font-medium">Average Demand (MWh):</strong> @areaInfo.AverageDemandMWh?.ToString("F2")"</p>
                <p><strong class="font-medium">Average Generation (MWh):</strong> @areaInfo.AverageGenerationMWh?.ToString("F2")</p>
                <p><strong class="font-medium">Total Outages:</strong> @areaInfo.TotalOutages</p>
            </div>
        </div>
        <div class="mb-6 flex space-x-4">
            <button class="rounded-lg bg-blue-600 px-6 py-3 font-semibold text-white transition-colors duration-200 hover:bg-blue-700"
                    @onclick="GeneratePrediction">
                Generate Predictions and Quantum Optimization
            </button>
            <button class="rounded-lg bg-green-600 px-6 py-3 font-semibold text-white transition-colors duration-200 hover:bg-green-700"
                    @onclick="ExportForQuantumAnalyst">
                Export for Quantum Analyst (Debug)
            </button>
        </div>
        @if (!string.IsNullOrEmpty(predictionMessage))
        {
            <div class="mt-6 flex items-center rounded-lg border p-4 @(predictionMessage.Contains("Error") ? "border-red-200 bg-red-50 text-red-700" : "border-green-200 bg-green-50 text-green-700")">
                @if (predictionMessage.Contains("Error"))
                {
                    <svg class="mr-2 h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z" clip-rule="evenodd" />
                    </svg>
                }
                else
                {
                    <svg class="mr-2 h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z" clip-rule="evenodd" />
                    </svg>
                }
                <p>@predictionMessage</p>
            </div>
        }
        @if (areaPredictions != null && areaPredictions.Any())
        {
            <div class="mt-6">
                <h2 class="mb-4 text-2xl font-semibold text-blue-900">Demand Predictions by Area</h2>
                @foreach (var prediction in areaPredictions)
                {
                    <div class="mb-6 rounded-xl border border-gray-100 bg-white p-6 shadow-lg">
                        <button @onclick="() => ToggleArea(prediction.Key)" class="w-full text-left flex items-center justify-between">
                            <h3 class="text-xl font-semibold text-blue-800">Area ID: @prediction.Key</h3>
                            <svg class="h-5 w-5 transform text-blue-600 @(areaToggles.ContainsKey(prediction.Key) && areaToggles[prediction.Key] ? "rotate-180" : "")" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                        @if (areaToggles.ContainsKey(prediction.Key) && areaToggles[prediction.Key])
                        {
                            <div class="mt-4">
                                <p class="text-gray-600"><strong class="font-medium">Prediction Timestamp:</strong> @prediction.Value.prediction_timestamp</p>
                                <div class="mt-4 overflow-x-auto">
                                    <table class="min-w-full table-auto border-collapse rounded-lg bg-white shadow-sm">
                                        <thead>
                                            <tr class="bg-blue-50 text-blue-900">
                                                <th class="px-6 py-3 text-left text-sm font-semibold">Date & Time</th>
                                                <th class="px-6 py-3 text-left text-sm font-semibold">Estimated Demand (MWh)</th>
                                                <th class="px-6 py-3 text-left text-sm font-semibold">Heat Index (°C)</th>
                                                <th class="px-6 py-3 text-left text-sm font-semibold">Temperature (°C)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            @foreach (var detail in prediction.Value.predictions)
                                            {
                                                <tr class="border-t border-gray-100 transition-colors duration-150 hover:bg-gray-50">
                                                    <td class="px-6 py-3 text-sm text-gray-600">@detail.timestamp</td>
                                                    <td class="px-6 py-3 text-sm text-gray-600">@detail.estimated_demand_mwh.ToString("F2")</td>
                                                    <td class="px-6 py-3 text-sm text-gray-600">@detail.heat_index.ToString("F2")</td>
                                                    <td class="px-6 py-3 text-sm text-gray-600">@detail.temperature_c.ToString("F1")</td>
                                                </tr>
                                            }
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
        }
        @if (quantumDecisions != null && quantumDecisions.Any())
        {
            <div class="mt-6">
                <h2 class="mb-4 text-2xl font-semibold text-blue-900">Quantum Optimization Results</h2>
                <div class="mb-6 rounded-xl border border-gray-100 bg-white p-6 shadow-lg">
                    <button @onclick="ToggleQuantumSection" class="flex w-full items-center justify-between text-left">
                        <h3 class="text-xl font-semibold text-blue-800">Decisions by Area</h3>
                        <svg class="h-5 w-5 transform text-blue-600 @(isQuantumSectionOpen ? "rotate-180" : "")" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </button>
                    @if (isQuantumSectionOpen)
                    {
                        <div class="mt-4 overflow-x-auto">
                            <table class="min-w-full table-auto border-collapse rounded-lg bg-white shadow-sm">
                                <thead>
                                    <tr class="bg-blue-50 text-blue-900">
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Area ID</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Name</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Action</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Target Power (MWh)</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Available Power (MWh)</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Priority</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Risk Level</th>
                                        <th class="px-6 py-3 text-left text-sm font-semibold">Justification</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var decision in quantumDecisions)
                                    {
                                        @if(decision.action == "solicitar_energia")
                                        {
                                            decision.action = "request_electricity";
                                        }
                                        @if(decision.action == "reducir_demanda")
                                        {
                                            decision.action = "decrease_demand";
                                        }
                                        @if(decision.risk_level == "bajo")
                                        {
                                            decision.risk_level = "low";
                                        }
                                        <tr class="border-t border-gray-100 transition-colors duration-150 hover:bg-gray-50">
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.area_id</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.area_name</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.action</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.target_power_mwh.ToString("F2")</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.available_power_mwh.ToString("F2")</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.priority</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.risk_level</td>
                                            <td class="px-6 py-3 text-sm text-gray-600">@decision.justification</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                    }
                </div>
            </div>
        }
    }
</div>

@code {
    [Parameter]
    public int AreaId { get; set; }
    private bool isLoading = false;
    private string? AreaName { get; set; }
    private AreaDetailsDto? areaInfo;
    private string predictionMessage = string.Empty;
    private Dictionary<int, AreaPredictionDto>? areaPredictions;
    private List<QuantumDecisionDto>? quantumDecisions;
    private Dictionary<int, bool> areaToggles = new();
    private bool isQuantumSectionOpen = false;

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;
        try
        {
            var client = HttpClientFactory.CreateClient("EnerQuantumApi");
            var response = await client.GetAsync($"/api/Areas/{AreaId}");
            if (response.IsSuccessStatusCode)
            {
                areaInfo = await response.Content.ReadFromJsonAsync<AreaDetailsDto>();
                AreaName = areaInfo?.Name;
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    private void ToggleArea(int areaId)
    {
        if (areaToggles.ContainsKey(areaId))
        {
            areaToggles[areaId] = !areaToggles[areaId];
        }
        else
        {
            areaToggles[areaId] = true;
        }
        StateHasChanged();
    }

    private void ToggleQuantumSection()
    {
        isQuantumSectionOpen = !isQuantumSectionOpen;
        StateHasChanged();
    }

    private async Task GeneratePrediction()
    {
        if (areaInfo == null) return;
        isLoading = true;
        predictionMessage = string.Empty;
        areaPredictions = null;
        quantumDecisions = null;
        areaToggles.Clear();
        isQuantumSectionOpen = false;
        try
        {
            var client = HttpClientFactory.CreateClient("EnerQuantumApi");
            var dataResponse = await client.GetAsync("/api/Areas/AllAreas");
            if (dataResponse.IsSuccessStatusCode)
            {
                var data = await dataResponse.Content.ReadFromJsonAsync<AllAreaDataDto>();
                if (data == null)
                {
                    predictionMessage = "Error: datos recibidos nulos.";
                    return;
                }

                // Flatten: Merge energy_usage + climate_events on timestamp/area_id + areas lookup
                var flattenedData = data.energy_usage.Select(eu =>
                {
                    var matchingClimate = data.climate_events.FirstOrDefault(ce =>
                        ce.start_timestamp.Date == eu.timestamp.Date &&
                        ce.start_timestamp.Hour == eu.timestamp.Hour &&
                        ce.area_id == eu.area_id);
                    var matchingArea = data.areas.FirstOrDefault(a => a.area_id == eu.area_id);

                    return new Dictionary<string, object?>
                    {
                        ["timestamp"] = eu.timestamp.ToString("yyyy-MM-ddTHH:mm:ssZ"),
                        ["areaId"] = eu.area_id,
                        ["areaName"] = matchingArea?.name ?? "Unknown",
                        ["latitude"] = matchingArea?.latitude ?? 21.1168,
                        ["longitude"] = matchingArea?.longitude ?? -101.6866,
                        ["gridType"] = matchingArea?.gridType ?? "microgrid:hospital",
                        ["generationMwh"] = eu.generation_mwh,
                        ["demandMwh"] = eu.demand_mwh,
                        ["serviceStatus"] = eu.serviceStatus ?? "normal",
                        ["lossesPct"] = eu.losses_pct,
                        ["circuit"] = eu.circuit ?? "",
                        ["durationHours"] = eu.durationHours,
                        ["importMwh"] = eu.import_mwh,
                        ["exportMwh"] = eu.export_mwh,
                        ["netExchangeMwh"] = eu.net_exchange_mwh,
                        ["tempC"] = matchingClimate?.temp_c ?? 20,
                        ["tempMinC"] = matchingClimate?.temp_min_c ?? 15,
                        ["tempMaxC"] = matchingClimate?.temp_max_c ?? 25,
                        ["climateCondition"] = matchingClimate?.climate_condition ?? "normal",
                        ["phenomenon"] = matchingClimate?.phenomenon ?? "none",
                        ["durationHoursClimate"] = matchingClimate?.durationHours ?? 24,
                        ["precipitationMm"] = matchingClimate?.precipitation_mm ?? 0,
                        ["windSpeedMps"] = matchingClimate?.wind_speed_mps ?? 5,
                        ["pressureHpa"] = matchingClimate?.pressure_hpa ?? 1013
                    };
                }).ToList();

                // Step 1: Send to AI API
                var payload = new { json_data = flattenedData };
                var aiClient = HttpClientFactory.CreateClient();
                aiClient.BaseAddress = new Uri("http://localhost:8000"); // AI API
                var predictResponse = await aiClient.PostAsJsonAsync("/predict?prediction_hours=24", payload);
                if (!predictResponse.IsSuccessStatusCode)
                {
                    predictionMessage = $"Error en predicción de IA: {await predictResponse.Content.ReadAsStringAsync()}";
                    return;
                }

                areaPredictions = await predictResponse.Content.ReadFromJsonAsync<Dictionary<int, AreaPredictionDto>>();
                var aiPredictionsJson = await predictResponse.Content.ReadAsStringAsync();
                Console.WriteLine(aiPredictionsJson);

                // Step 2: Transform AI predictions to Quantum API format
                var quantumPayloadData = new Dictionary<string, object>();
                foreach (var area in data.areas)
                {
                    var areaPrediction = areaPredictions.ContainsKey(area.area_id) ? areaPredictions[area.area_id] : null;
                    if (areaPrediction == null) continue;

                    var areaData = new Dictionary<string, object>
                    {
                        ["area_id"] = area.area_id,
                        ["area_name"] = area.name,
                        ["generation_capacity_mwh"] = data.energy_usage
                            .Where(eu => eu.area_id == area.area_id)
                            .Average(eu => eu.generation_mwh),
                        ["prediction_timestamp"] = areaPrediction.prediction_timestamp,
                        ["overall_risk_assessment"] = new Dictionary<string, object>
                        {
                            ["average_risk_percentage"] = areaPrediction.predictions.Any()
                                ? areaPrediction.predictions.Average(p => p.heat_index / 40.0 * 100)
                                : 0.0,
                            ["level"] = areaPrediction.predictions.Any()
                                ? (areaPrediction.predictions.Average(p => p.heat_index) > 30 ? "alto" :
                                   areaPrediction.predictions.Average(p => p.heat_index) > 20 ? "medio" : "bajo")
                                : "bajo"
                        },
                        ["predictions"] = areaPrediction.predictions.Select(p => new Dictionary<string, object>
                        {
                            ["timestamp"] = p.timestamp,
                            ["estimated_demand_mwh"] = p.estimated_demand_mwh,
                            ["heat_index"] = p.heat_index,
                            ["temperature_c"] = p.temperature_c,
                            ["blackout_risk"] = new Dictionary<string, object>
                            {
                                ["blackout_probability"] = p.heat_index > 30 ? "alta" : p.heat_index > 20 ? "media" : "baja",
                                ["capacity_utilization"] = Math.Min(100, p.estimated_demand_mwh / (data.energy_usage
                                    .Where(eu => eu.area_id == area.area_id)
                                    .Average(eu => eu.generation_mwh) + 0.001) * 100),
                                ["demand_vs_critical_load"] = p.estimated_demand_mwh,
                                ["emergency_reserves_needed"] = p.estimated_demand_mwh > data.energy_usage
                                    .Where(eu => eu.area_id == area.area_id)
                                    .Average(eu => eu.generation_mwh) ? p.estimated_demand_mwh - data.energy_usage
                                    .Where(eu => eu.area_id == area.area_id)
                                    .Average(eu => eu.generation_mwh) : 0,
                                ["risk_level"] = p.heat_index > 30 ? "alto" : p.heat_index > 20 ? "medio" : "bajo",
                                ["risk_percentage"] = p.heat_index / 40.0 * 100,
                                ["safety_margin_mwh"] = data.energy_usage
                                    .Where(eu => eu.area_id == area.area_id)
                                    .Average(eu => eu.generation_mwh) - p.estimated_demand_mwh
                            }
                        }).ToList()
                    };
                    quantumPayloadData[area.area_id.ToString()] = areaData;
                }

                // Step 3: Send to Quantum API
                var quantumClient = HttpClientFactory.CreateClient();
                quantumClient.BaseAddress = new Uri("http://localhost:8001"); // Quantum API
                var quantumPayload = new StringContent(
                    JsonSerializer.Serialize(new { ai_data = quantumPayloadData }),
                    System.Text.Encoding.UTF8,
                    "application/json"
                );
                var quantumResponse = await quantumClient.PostAsync("/optimize-energy", quantumPayload);

                if (quantumResponse.IsSuccessStatusCode)
                {
                    var quantumResults = await quantumResponse.Content.ReadFromJsonAsync<QuantumOptimizationResponseDto>();
                    quantumDecisions = quantumResults?.decisions;
                    predictionMessage = "AI Predictions And Quantum Optimization Loaded";
                }
                else
                {
                    predictionMessage = $"Error en optimización cuántica: {await quantumResponse.Content.ReadAsStringAsync()}";
                }
            }
            else
            {
                predictionMessage = $"Error al obtener datos: {await dataResponse.Content.ReadAsStringAsync()}";
            }
        }
        catch (Exception ex)
        {
            predictionMessage = $"Error al generar predicción u optimización: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task ExportForQuantumAnalyst()
    {
        if (areaInfo == null) return;
        isLoading = true;
        predictionMessage = string.Empty;
        try
        {
            var client = HttpClientFactory.CreateClient("EnerQuantumApi");
            var dataResponse = await client.GetAsync("/api/Areas/AllAreas");
            if (!dataResponse.IsSuccessStatusCode)
            {
                predictionMessage = $"Error al obtener datos: {await dataResponse.Content.ReadAsStringAsync()}";
                return;
            }

            var data = await dataResponse.Content.ReadFromJsonAsync<AllAreaDataDto>();
            if (data == null)
            {
                predictionMessage = "Error: datos recibidos nulos.";
                return;
            }

            var flattenedData = data.energy_usage.Select(eu =>
            {
                var matchingClimate = data.climate_events.FirstOrDefault(ce =>
                    ce.start_timestamp.Date == eu.timestamp.Date &&
                    ce.start_timestamp.Hour == eu.timestamp.Hour &&
                    ce.area_id == eu.area_id);
                var matchingArea = data.areas.FirstOrDefault(a => a.area_id == eu.area_id);

                return new Dictionary<string, object?>
                {
                    ["timestamp"] = eu.timestamp.ToString("yyyy-MM-ddTHH:mm:ssZ"),
                    ["areaId"] = eu.area_id,
                    ["areaName"] = matchingArea?.name,
                    ["latitude"] = matchingArea?.latitude ?? 21.1168,
                    ["longitude"] = matchingArea?.longitude ?? -101.6866,
                    ["gridType"] = matchingArea?.gridType ?? "microgrid:hospital",
                    ["generationMwh"] = eu.generation_mwh,
                    ["demandMwh"] = eu.demand_mwh,
                    ["serviceStatus"] = eu.serviceStatus ?? "normal",
                    ["lossesPct"] = eu.losses_pct,
                    ["circuit"] = eu.circuit ?? "",
                    ["durationHours"] = eu.durationHours,
                    ["importMwh"] = eu.import_mwh,
                    ["exportMwh"] = eu.export_mwh,
                    ["netExchangeMwh"] = eu.net_exchange_mwh,
                    ["tempC"] = matchingClimate?.temp_c ?? 20,
                    ["tempMinC"] = matchingClimate?.temp_min_c ?? 15,
                    ["tempMaxC"] = matchingClimate?.temp_max_c ?? 25,
                    ["climateCondition"] = matchingClimate?.climate_condition ?? "normal",
                    ["phenomenon"] = matchingClimate?.phenomenon ?? "none",
                    ["durationHoursClimate"] = matchingClimate?.durationHours ?? 24,
                    ["precipitationMm"] = matchingClimate?.precipitation_mm ?? 0,
                    ["windSpeedMps"] = matchingClimate?.wind_speed_mps ?? 5,
                    ["pressureHpa"] = matchingClimate?.pressure_hpa ?? 1013
                };
            }).ToList();

            var payload = new { json_data = flattenedData };
            var aiClient = HttpClientFactory.CreateClient();
            aiClient.BaseAddress = new Uri("http://localhost:8000"); // AI API
            var predictResponse = await aiClient.PostAsJsonAsync("/predict?prediction_hours=24", payload);

            if (!predictResponse.IsSuccessStatusCode)
            {
                predictionMessage = $"Error en predicción de IA: {await predictResponse.Content.ReadAsStringAsync()}";
                return;
            }

            var predictions = await predictResponse.Content.ReadAsStringAsync();
            var quantumClient = HttpClientFactory.CreateClient();
            quantumClient.BaseAddress = new Uri("http://localhost:8001"); // Quantum API
            var quantumPayload = new StringContent(predictions, System.Text.Encoding.UTF8, "application/json");
            var quantumResponse = await quantumClient.PostAsync("/optimize-energy", quantumPayload);

            if (quantumResponse.IsSuccessStatusCode)
            {
                var quantumResults = await quantumResponse.Content.ReadAsStringAsync();
                await JSRuntime.InvokeVoidAsync("downloadFile",
                    $"quantum_optimization_{DateTime.Now:yyyyMMdd_HHmmss}.json",
                    "application/json",
                    quantumResults);
                predictionMessage = "Optimización cuántica completada. JSON descargado.";
            }
            else
            {
                predictionMessage = $"Error en optimización cuántica: {await quantumResponse.Content.ReadAsStringAsync()}";
            }
        }
        catch (Exception ex)
        {
            predictionMessage = $"Error en exportación: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    public class AreaDetailsDto
    {
        public int AreaId { get; set; }
        public string Name { get; set; } = string.Empty;
        public double? Latitude { get; set; }
        public double? Longitude { get; set; }
        public string GridType { get; set; } = string.Empty;
        public double? AverageDemandMWh { get; set; }
        public double? AverageGenerationMWh { get; set; }
        public int TotalOutages { get; set; }
    }

    public class AreaPredictionDto
    {
        public int area_id { get; set; }
        public string prediction_timestamp { get; set; } = string.Empty;
        public List<PredictionDetail> predictions { get; set; } = new List<PredictionDetail>();
    }

    public class PredictionDetail
    {
        public string timestamp { get; set; } = string.Empty;
        public double estimated_demand_mwh { get; set; }
        public double heat_index { get; set; }
        public double temperature_c { get; set; }
    }

    public class QuantumDecisionDto
    {
        public int area_id { get; set; }
        public string area_name { get; set; } = string.Empty;
        public string redistribution_type { get; set; } = string.Empty;
        public string action { get; set; } = string.Empty;
        public double target_power_mwh { get; set; }
        public double available_power_mwh { get; set; }
        public int priority { get; set; }
        public string risk_level { get; set; } = string.Empty;
        public double safety_margin_mwh { get; set; }
        public double quantum_confidence { get; set; }
        public string justification { get; set; } = string.Empty;
    }

    public class QuantumOptimizationResponseDto
    {
        public string timestamp { get; set; } = string.Empty;
        public int total_areas { get; set; }
        public bool quantum_optimization { get; set; }
        public List<QuantumDecisionDto> decisions { get; set; } = new List<QuantumDecisionDto>();
        public Dictionary<string, List<Dictionary<string, object>>> redistribution_summary { get; set; } = new Dictionary<string, List<Dictionary<string, object>>>();
        public Dictionary<string, object>? quantum_metadata { get; set; }
    }

    public class AllAreaDataDto
    {
        public List<AreaDto> areas { get; set; } = new();
        public List<EnergyUsageDto> energy_usage { get; set; } = new();
        public List<ClimateEventDto> climate_events { get; set; } = new();
        public Dictionary<string, object> infrastructure { get; set; } = new();
    }

    public class AreaDto
    {
        public int area_id { get; set; }
        public string name { get; set; } = string.Empty;
        public double latitude { get; set; }
        public double longitude { get; set; }
        public string gridType { get; set; } = string.Empty;
    }

    public class EnergyUsageDto
    {
        public DateTime timestamp { get; set; }
        public int area_id { get; set; }
        public double generation_mwh { get; set; }
        public double demand_mwh { get; set; }
        public string serviceStatus { get; set; } = string.Empty;
        public double losses_pct { get; set; }
        public string circuit { get; set; } = string.Empty;
        public double durationHours { get; set; }
        public double? import_mwh { get; set; }
        public double? export_mwh { get; set; }
        public double? net_exchange_mwh { get; set; }
    }

    public class ClimateEventDto
    {
        public DateTime start_timestamp { get; set; }
        public int area_id { get; set; }
        public double temp_c { get; set; }
        public double temp_min_c { get; set; }
        public double temp_max_c { get; set; }
        public string climate_condition { get; set; } = string.Empty;
        public string phenomenon { get; set; } = string.Empty;
        public double durationHours { get; set; }
        public double precipitation_mm { get; set; }
        public double wind_speed_mps { get; set; }
        public double pressure_hpa { get; set; }
    }
}